import ytdl from '@distube/ytdl-core';
import * as discord_js from 'discord.js';
import { GuildTextBasedChannel, Message, Snowflake, VoiceBasedChannel, VoiceState, Guild, GuildMember, Interaction, Client, Collection, ClientOptions } from 'discord.js';
import { Video, Playlist as Playlist$1 } from '@distube/ytsr';
import { TypedEmitter } from 'tiny-typed-emitter';
import { AudioPlayer, VoiceConnection, AudioResource, StreamType as StreamType$1 } from '@discordjs/voice';
import { FFmpeg } from 'prism-media';
import * as _discordjs_collection from '@discordjs/collection';

declare type Awaitable<T = any> = T | PromiseLike<T>;
declare type DisTubeVoiceEvents = {
    disconnect: (error?: Error) => Awaitable;
    error: (error: Error) => Awaitable;
    finish: () => Awaitable;
};
declare enum Events {
    ERROR = "error",
    ADD_LIST = "addList",
    ADD_SONG = "addSong",
    PLAY_SONG = "playSong",
    FINISH_SONG = "finishSong",
    EMPTY = "empty",
    FINISH = "finish",
    INIT_QUEUE = "initQueue",
    NO_RELATED = "noRelated",
    DISCONNECT = "disconnect",
    DELETE_QUEUE = "deleteQueue",
    SEARCH_CANCEL = "searchCancel",
    SEARCH_NO_RESULT = "searchNoResult",
    SEARCH_DONE = "searchDone",
    SEARCH_INVALID_ANSWER = "searchInvalidAnswer",
    SEARCH_RESULT = "searchResult"
}
declare type DisTubeEvents = {
    error: [channel: GuildTextBasedChannel | undefined, error: Error];
    addList: [queue: Queue, playlist: Playlist];
    addSong: [queue: Queue, song: Song];
    playSong: [queue: Queue, song: Song];
    finishSong: [queue: Queue, song: Song];
    empty: [queue: Queue];
    finish: [queue: Queue];
    initQueue: [queue: Queue];
    noRelated: [queue: Queue];
    disconnect: [queue: Queue];
    deleteQueue: [queue: Queue];
    searchCancel: [message: Message<true>, query: string];
    searchNoResult: [message: Message<true>, query: string];
    searchDone: [message: Message<true>, answer: Message<true>, query: string];
    searchInvalidAnswer: [message: Message<true>, answer: Message<true>, query: string];
    searchResult: [message: Message<true>, results: SearchResult[], query: string];
};
declare type TypedDisTubeEvents = {
    [K in keyof DisTubeEvents]: (...args: DisTubeEvents[K]) => Awaitable;
};
interface Filter {
    name: string;
    value: string;
}
declare type FilterResolvable = string | Filter;
declare type Filters = Record<string, string>;
interface DisTubeOptions {
    plugins?: (CustomPlugin | ExtractorPlugin)[];
    emitNewSongOnly?: boolean;
    leaveOnFinish?: boolean;
    leaveOnStop?: boolean;
    leaveOnEmpty?: boolean;
    emptyCooldown?: number;
    savePreviousSongs?: boolean;
    searchSongs?: number;
    searchCooldown?: number;
    youtubeCookie?: string;
    youtubeIdentityToken?: string;
    customFilters?: Filters;
    ytdlOptions?: ytdl.downloadOptions;
    nsfw?: boolean;
    emitAddSongWhenCreatingQueue?: boolean;
    emitAddListWhenCreatingQueue?: boolean;
    joinNewVoiceChannel?: boolean;
    streamType?: StreamType;
    directLink?: boolean;
}
declare type GuildIdResolvable = Queue | DisTubeVoice | Snowflake | Message | GuildTextBasedChannel | VoiceBasedChannel | VoiceState | Guild | GuildMember | Interaction | string;
interface OtherSongInfo {
    src?: string;
    id?: string;
    title?: string;
    name?: string;
    is_live?: boolean;
    isLive?: boolean;
    _duration_raw?: string | number;
    duration?: string | number;
    webpage_url?: string;
    url: string;
    thumbnail?: string;
    related?: RelatedSong[];
    view_count?: string | number;
    views?: string | number;
    like_count?: string | number;
    likes?: string | number;
    dislike_count?: string | number;
    dislikes?: string | number;
    repost_count?: string | number;
    reposts?: string | number;
    uploader?: string | {
        name: string;
        url: string;
    };
    uploader_url?: string;
    age_limit?: string | number;
    chapters?: Chapter[];
    age_restricted?: boolean;
}
interface Chapter {
    title: string;
    start_time: number;
}
interface PlaylistInfo {
    source: string;
    member?: GuildMember;
    songs: Song[];
    name?: string;
    url?: string;
    thumbnail?: string;
    title?: string;
    webpage_url?: string;
}
declare type RelatedSong = Omit<Song, "related">;
declare type PlayHandlerOptions = {
    skip?: boolean;
    position?: number;
    textChannel?: GuildTextBasedChannel;
};
interface PlayOptions extends PlayHandlerOptions, ResolveOptions<any> {
    message?: Message;
}
interface ResolveOptions<T = unknown> {
    member?: GuildMember;
    metadata?: T;
}
interface ResolvePlaylistOptions<T = unknown> extends ResolveOptions<T> {
    source?: string;
}
interface CustomPlaylistOptions {
    member?: GuildMember;
    properties?: Record<string, any>;
    parallel?: boolean;
    metadata?: any;
}
declare enum RepeatMode {
    DISABLED = 0,
    SONG = 1,
    QUEUE = 2
}
declare enum PluginType {
    CUSTOM = "custom",
    EXTRACTOR = "extractor"
}
declare enum SearchResultType {
    VIDEO = "video",
    PLAYLIST = "playlist"
}
declare enum StreamType {
    OPUS = 0,
    RAW = 1
}

declare const defaultFilters: Filters;
declare const defaultOptions: {
    plugins: never[];
    emitNewSongOnly: boolean;
    leaveOnEmpty: boolean;
    leaveOnFinish: boolean;
    leaveOnStop: boolean;
    savePreviousSongs: boolean;
    searchSongs: number;
    ytdlOptions: {};
    searchCooldown: number;
    emptyCooldown: number;
    nsfw: boolean;
    emitAddSongWhenCreatingQueue: boolean;
    emitAddListWhenCreatingQueue: boolean;
    joinNewVoiceChannel: boolean;
    streamType: StreamType;
    directLink: boolean;
};

declare const ERROR_MESSAGES: {
    INVALID_TYPE: (expected: (number | string) | readonly (number | string)[], got: any, name?: string) => string;
    NUMBER_COMPARE: (name: string, expected: string, value: number) => string;
    EMPTY_ARRAY: (name: string) => string;
    EMPTY_FILTERED_ARRAY: (name: string, type: string) => string;
    EMPTY_STRING: (name: string) => string;
    INVALID_KEY: (obj: string, key: string) => string;
    MISSING_KEY: (obj: string, key: string) => string;
    MISSING_KEYS: (obj: string, key: string[], all: boolean) => string;
    MISSING_INTENTS: (i: string) => string;
    DISABLED_OPTION: (o: string) => string;
    ENABLED_OPTION: (o: string) => string;
    NOT_IN_VOICE: string;
    VOICE_FULL: string;
    VOICE_CONNECT_FAILED: (s: number) => string;
    VOICE_MISSING_PERMS: string;
    VOICE_RECONNECT_FAILED: string;
    VOICE_DIFFERENT_GUILD: string;
    VOICE_DIFFERENT_CLIENT: string;
    NO_QUEUE: string;
    QUEUE_EXIST: string;
    PAUSED: string;
    RESUMED: string;
    NO_PREVIOUS: string;
    NO_UP_NEXT: string;
    NO_SONG_POSITION: string;
    NO_PLAYING: string;
    NO_RESULT: string;
    NO_RELATED: string;
    CANNOT_PLAY_RELATED: string;
    UNAVAILABLE_VIDEO: string;
    UNPLAYABLE_FORMATS: string;
    NON_NSFW: string;
    NOT_SUPPORTED_URL: string;
    CANNOT_RESOLVE_SONG: (t: any) => string;
    NO_VALID_SONG: string;
    EMPTY_FILTERED_PLAYLIST: string;
    EMPTY_PLAYLIST: string;
};
declare type ErrorMessage = typeof ERROR_MESSAGES;
declare type ErrorCode = keyof ErrorMessage;
declare type StaticErrorCode = {
    [K in ErrorCode]-?: ErrorMessage[K] extends string ? K : never;
}[ErrorCode];
declare type TemplateErrorCode = Exclude<keyof typeof ERROR_MESSAGES, StaticErrorCode>;
declare class DisTubeError<T extends string> extends Error {
    errorCode: string;
    constructor(code: StaticErrorCode);
    constructor(code: T extends TemplateErrorCode ? T : never, ...args: Parameters<ErrorMessage[typeof code]>);
    constructor(code: TemplateErrorCode, _: never);
    constructor(code: T extends ErrorCode ? "This is built-in error code" : T, message: string);
    get name(): string;
    get code(): string;
}

declare class TaskQueue {
    #private;
    queuing(resolveInfo?: boolean): Promise<void>;
    resolve(): void;
    get remaining(): number;
    get hasResolveTask(): boolean;
}

declare class Playlist<T = unknown> implements PlaylistInfo {
    #private;
    source: string;
    songs: Song[];
    name: string;
    url?: string;
    thumbnail?: string;
    [x: string]: any;
    constructor(playlist: Song[] | PlaylistInfo, options?: {
        member?: GuildMember;
        properties?: Record<string, any>;
        metadata?: T;
    });
    get duration(): number;
    get formattedDuration(): string;
    get member(): GuildMember | undefined;
    set member(member: GuildMember | undefined);
    get user(): discord_js.User | undefined;
    get metadata(): T;
    set metadata(metadata: T);
}

declare abstract class ISearchResult {
    source: "youtube";
    abstract type: SearchResultType;
    id: string;
    name: string;
    url: string;
    uploader: {
        name?: string;
        url?: string;
    };
    constructor(info: Video | Playlist$1);
}
declare class SearchResultVideo extends ISearchResult {
    type: SearchResultType.VIDEO;
    views: number;
    isLive: boolean;
    duration: number;
    formattedDuration: string;
    thumbnail: string;
    constructor(info: Video);
}
declare type SearchResult = SearchResultVideo | SearchResultPlaylist;
declare class SearchResultPlaylist extends ISearchResult {
    type: SearchResultType.PLAYLIST;
    length: number;
    constructor(info: Playlist$1);
}

declare class Song<T = unknown> {
    #private;
    source: string;
    formats?: ytdl.videoFormat[];
    id?: string;
    name?: string;
    isLive: boolean;
    duration: number;
    formattedDuration?: string;
    url: string;
    streamURL?: string;
    thumbnail?: string;
    related: RelatedSong[];
    views: number;
    likes: number;
    dislikes: number;
    uploader: {
        name?: string;
        url?: string;
    };
    age_restricted: boolean;
    chapters: Chapter[];
    reposts: number;
    constructor(info: ytdl.videoInfo | SearchResult | OtherSongInfo | ytdl.relatedVideo | RelatedSong, options?: {
        member?: GuildMember;
        source?: string;
        metadata?: T;
    });
    _patchYouTube(i: ytdl.videoInfo | SearchResult): void;
    _patchOther(info: OtherSongInfo): void;
    get playlist(): Playlist | undefined;
    set playlist(playlist: Playlist | undefined);
    get member(): GuildMember | undefined;
    set member(member: GuildMember | undefined);
    get user(): discord_js.User | undefined;
    get metadata(): T;
    set metadata(metadata: T);
}

declare abstract class DisTubeBase {
    distube: DisTube;
    constructor(distube: DisTube);
    emit(eventName: keyof DisTubeEvents, ...args: any): boolean;
    emitError(error: Error, channel?: GuildTextBasedChannel): void;
    get queues(): QueueManager;
    get voices(): DisTubeVoiceManager;
    get client(): Client;
    get options(): Options;
    get handler(): DisTubeHandler;
}

declare class DisTubeVoice extends TypedEmitter<DisTubeVoiceEvents> {
    #private;
    readonly id: Snowflake;
    readonly voices: DisTubeVoiceManager;
    readonly audioPlayer: AudioPlayer;
    connection: VoiceConnection;
    audioResource?: AudioResource;
    emittedError: boolean;
    isDisconnected: boolean;
    constructor(voiceManager: DisTubeVoiceManager, channel: VoiceBasedChannel);
    get channelId(): string | undefined;
    get channel(): VoiceBasedChannel;
    set channel(channel: VoiceBasedChannel);
    join(channel?: VoiceBasedChannel): Promise<DisTubeVoice>;
    leave(error?: Error): void;
    stop(force?: boolean): void;
    play(stream: DisTubeStream): void;
    set volume(volume: number);
    get volume(): number;
    get playbackDuration(): number;
    pause(): void;
    unpause(): void;
    get selfDeaf(): boolean;
    get selfMute(): boolean;
    setSelfDeaf(selfDeaf: boolean): boolean;
    setSelfMute(selfMute: boolean): boolean;
    get voiceState(): VoiceState | undefined;
}

declare abstract class BaseManager<V> extends DisTubeBase {
    collection: Collection<string, V>;
    get size(): number;
}

declare abstract class GuildIdManager<V> extends BaseManager<V> {
    add(idOrInstance: GuildIdResolvable, data: V): this | _discordjs_collection.Collection<string, V>;
    get(idOrInstance: GuildIdResolvable): V | undefined;
    remove(idOrInstance: GuildIdResolvable): boolean;
    has(idOrInstance: GuildIdResolvable): boolean;
}

declare class DisTubeVoiceManager extends GuildIdManager<DisTubeVoice> {
    create(channel: VoiceBasedChannel): DisTubeVoice;
    join(channel: VoiceBasedChannel): Promise<DisTubeVoice>;
    leave(guild: GuildIdResolvable): void;
}

declare class FilterManager extends BaseManager<FilterResolvable> {
    #private;
    queue: Queue;
    constructor(queue: Queue);
    add(filterOrFilters: FilterResolvable | FilterResolvable[], override?: boolean): this;
    clear(): this;
    set(filters: FilterResolvable[]): this;
    remove(filterOrFilters: FilterResolvable | FilterResolvable[]): this;
    has(filter: FilterResolvable): boolean;
    get names(): string[];
    get values(): string[];
    toString(): string;
}

declare class QueueManager extends GuildIdManager<Queue> {
    #private;
    create(channel: VoiceBasedChannel, song: Song[] | Song, textChannel?: GuildTextBasedChannel): Promise<Queue | true>;
    createStream(queue: Queue): DisTubeStream;
    playSong(queue: Queue): Promise<boolean>;
}

declare class DisTubeHandler extends DisTubeBase {
    constructor(distube: DisTube);
    get ytdlOptions(): ytdl.getInfoOptions;
    getYouTubeInfo(url: string, basic?: boolean): Promise<ytdl.videoInfo>;
    resolve<T = unknown>(song: Song<T>, options?: Omit<ResolveOptions, "metadata">): Promise<Song<T>>;
    resolve<T = unknown>(song: Playlist<T>, options?: Omit<ResolveOptions, "metadata">): Promise<Playlist<T>>;
    resolve<T = unknown>(song: string | SearchResult, options?: ResolveOptions<T>): Promise<Song<T> | Playlist<T>>;
    resolve<T = unknown>(song: ytdl.videoInfo | OtherSongInfo | ytdl.relatedVideo, options?: ResolveOptions<T>): Promise<Song<T>>;
    resolve<T = unknown>(song: Playlist, options: ResolveOptions<T>): Promise<Playlist<T>>;
    resolve(song: string | ytdl.videoInfo | Song | Playlist | SearchResult | OtherSongInfo | ytdl.relatedVideo, options?: ResolveOptions): Promise<Song | Playlist>;
    resolvePlaylist<T = unknown>(playlist: Playlist<T> | Song<T>[] | string, options?: Omit<ResolvePlaylistOptions, "metadata">): Promise<Playlist<T>>;
    resolvePlaylist<T = undefined>(playlist: Playlist | Song[] | string, options: ResolvePlaylistOptions<T>): Promise<Playlist<T>>;
    resolvePlaylist(playlist: Playlist | Song[] | string, options?: ResolvePlaylistOptions): Promise<Playlist>;
    searchSong(message: Message<true>, query: string): Promise<SearchResult | null>;
    createSearchMessageCollector<R extends SearchResult | Song | Playlist>(message: Message<true>, results: Array<R>, query?: string): Promise<R | null>;
    playPlaylist(voiceChannel: VoiceBasedChannel, playlist: Playlist, options?: PlayHandlerOptions): Promise<void>;
    playSong(voiceChannel: VoiceBasedChannel, song: Song, options?: PlayHandlerOptions): Promise<void>;
}

declare class Options {
    #private;
    plugins: (CustomPlugin | ExtractorPlugin)[];
    emitNewSongOnly: boolean;
    leaveOnFinish: boolean;
    leaveOnStop: boolean;
    leaveOnEmpty: boolean;
    emptyCooldown: number;
    savePreviousSongs: boolean;
    searchSongs: number;
    searchCooldown: number;
    youtubeCookie?: string;
    youtubeIdentityToken?: string;
    customFilters?: Filters;
    ytdlOptions: ytdl.getInfoOptions;
    nsfw: boolean;
    emitAddSongWhenCreatingQueue: boolean;
    emitAddListWhenCreatingQueue: boolean;
    joinNewVoiceChannel: boolean;
    streamType: StreamType;
    directLink: boolean;
    constructor(options: DisTubeOptions);
}

interface StreamOptions {
    seek?: number;
    ffmpegArgs?: string[];
    isLive?: boolean;
    type?: StreamType;
}
declare const chooseBestVideoFormat: (formats: ytdl.videoFormat[], isLive?: boolean) => ytdl.videoFormat;
declare class DisTubeStream {
    static YouTube(formats: ytdl.videoFormat[] | undefined, options?: StreamOptions): DisTubeStream;
    static DirectLink(url: string, options?: StreamOptions): DisTubeStream;
    type: StreamType$1;
    stream: FFmpeg;
    url: string;
    constructor(url: string, options: StreamOptions);
}

declare class Queue extends DisTubeBase {
    #private;
    readonly id: Snowflake;
    voice: DisTubeVoice;
    songs: Song[];
    previousSongs: Song[];
    stopped: boolean;
    _next: boolean;
    _prev: boolean;
    playing: boolean;
    paused: boolean;
    repeatMode: RepeatMode;
    autoplay: boolean;
    beginTime: number;
    textChannel?: GuildTextBasedChannel;
    _emptyTimeout?: NodeJS.Timeout;
    _taskQueue: TaskQueue;
    _listeners?: DisTubeVoiceEvents;
    constructor(distube: DisTube, voice: DisTubeVoice, song: Song | Song[], textChannel?: GuildTextBasedChannel);
    get clientMember(): discord_js.GuildMember | undefined;
    get filters(): FilterManager;
    get formattedDuration(): string;
    get duration(): number;
    get currentTime(): number;
    get formattedCurrentTime(): string;
    get voiceChannel(): discord_js.VoiceBasedChannel | null;
    get volume(): number;
    set volume(value: number);
    addToQueue(song: Song | Song[], position?: number): Queue;
    pause(): Queue;
    resume(): Queue;
    setVolume(percent: number): Queue;
    skip(): Promise<Song>;
    previous(): Promise<Song>;
    shuffle(): Promise<Queue>;
    jump(position: number): Promise<Song>;
    setRepeatMode(mode?: RepeatMode): RepeatMode;
    seek(time: number): Queue;
    addRelatedSong(): Promise<Song>;
    stop(): Promise<void>;
    remove(): void;
    toggleAutoplay(): boolean;
}

declare abstract class Plugin {
    abstract type: PluginType;
    distube: DisTube;
    init(distube: DisTube): void;
    emit(eventName: keyof DisTubeEvents, ...args: any): boolean;
    emitError(error: Error, channel?: GuildTextBasedChannel): void;
    get queues(): QueueManager;
    get voices(): DisTubeVoiceManager;
    get client(): Client;
    get options(): Options;
    get handler(): DisTubeHandler;
    validate(_string: string): Awaitable<boolean>;
    getStreamURL(url: string): Awaitable<string>;
    getRelatedSongs(_url: string): Awaitable<RelatedSong[]>;
}

declare abstract class CustomPlugin extends Plugin {
    readonly type = PluginType.CUSTOM;
    abstract play(voiceChannel: VoiceBasedChannel, song: string, options: PlayOptions): Awaitable<void>;
}

declare abstract class ExtractorPlugin extends Plugin {
    readonly type = PluginType.EXTRACTOR;
    abstract resolve<T = unknown>(url: string, options: {
        member?: GuildMember;
        metadata?: T;
    }): Awaitable<Song<T> | Playlist<T>>;
}

declare function formatDuration(sec: number): string;
declare function toSecond(input: any): number;
declare function parseNumber(input: any): number;
declare function isURL(input: any): input is `http://${string}` | `https://${string}`;
declare function checkIntents(options: ClientOptions): void;
declare function isVoiceChannelEmpty(voiceState: VoiceState): boolean;
declare function isSnowflake(id: any): id is Snowflake;
declare function isMemberInstance(member: any): member is GuildMember;
declare function isTextChannelInstance(channel: any): channel is GuildTextBasedChannel;
declare function isMessageInstance(message: any): message is Message<true>;
declare function isSupportedVoiceChannel(channel: any): channel is VoiceBasedChannel;
declare function isGuildInstance(guild: any): guild is Guild;
declare function resolveGuildId(resolvable: GuildIdResolvable): Snowflake;
declare function isClientInstance(client: any): client is Client;
declare function checkInvalidKey(target: Record<string, any>, source: Record<string, any> | string[], sourceName: string): void;
declare function isObject(obj: any): obj is object;
declare function isRecord<T = unknown>(obj: any): obj is Record<string, T>;
declare type KeyOf<T> = T extends object ? (keyof T)[] : [];
declare function objectKeys<T>(obj: T): KeyOf<T>;

declare class DirectLinkPlugin extends ExtractorPlugin {
    validate(url: string): Promise<boolean>;
    resolve(url: string, options?: {
        member?: GuildMember;
        metadata?: any;
    }): Promise<Song<any>>;
}

declare const version: string;
declare class DisTube extends TypedEmitter<TypedDisTubeEvents> {
    readonly handler: DisTubeHandler;
    readonly options: Options;
    readonly client: Client;
    readonly queues: QueueManager;
    readonly voices: DisTubeVoiceManager;
    readonly extractorPlugins: ExtractorPlugin[];
    readonly customPlugins: CustomPlugin[];
    readonly filters: Filters;
    constructor(client: Client, otp?: DisTubeOptions);
    static get version(): string;
    get version(): string;
    play(voiceChannel: VoiceBasedChannel, song: string | Song | SearchResult | Playlist, options?: PlayOptions): Promise<void>;
    createCustomPlaylist(songs: (string | Song | SearchResult)[], options?: CustomPlaylistOptions): Promise<Playlist>;
    search(string: string, options?: {
        type?: SearchResultType;
        limit?: number;
        safeSearch?: boolean;
        retried?: boolean;
    }): Promise<Array<SearchResult>>;
    search(string: string, options?: {
        type?: SearchResultType.VIDEO;
        limit?: number;
        safeSearch?: boolean;
        retried?: boolean;
    }): Promise<Array<SearchResultVideo>>;
    search(string: string, options: {
        type: SearchResultType.PLAYLIST;
        limit?: number;
        safeSearch?: boolean;
        retried?: boolean;
    }): Promise<Array<SearchResultPlaylist>>;
    getQueue(guild: GuildIdResolvable): Queue | undefined;
    pause(guild: GuildIdResolvable): Queue;
    resume(guild: GuildIdResolvable): Queue;
    stop(guild: GuildIdResolvable): Promise<void>;
    setVolume(guild: GuildIdResolvable, percent: number): Queue;
    skip(guild: GuildIdResolvable): Promise<Song>;
    previous(guild: GuildIdResolvable): Promise<Song>;
    shuffle(guild: GuildIdResolvable): Promise<Queue>;
    jump(guild: GuildIdResolvable, num: number): Promise<Song>;
    setRepeatMode(guild: GuildIdResolvable, mode?: number): number;
    toggleAutoplay(guild: GuildIdResolvable): boolean;
    addRelatedSong(guild: GuildIdResolvable): Promise<Song>;
    seek(guild: GuildIdResolvable, time: number): Queue;
    emitError(error: Error, channel?: GuildTextBasedChannel): void;
}

export { Awaitable, BaseManager, Chapter, CustomPlaylistOptions, CustomPlugin, DirectLinkPlugin, DisTube, DisTubeBase, DisTubeError, DisTubeEvents, DisTubeHandler, DisTubeOptions, DisTubeStream, DisTubeVoice, DisTubeVoiceEvents, DisTubeVoiceManager, Events, ExtractorPlugin, Filter, FilterManager, FilterResolvable, Filters, GuildIdManager, GuildIdResolvable, Options, OtherSongInfo, PlayHandlerOptions, PlayOptions, Playlist, PlaylistInfo, Plugin, PluginType, Queue, QueueManager, RelatedSong, RepeatMode, ResolveOptions, ResolvePlaylistOptions, SearchResult, SearchResultPlaylist, SearchResultType, SearchResultVideo, Song, StreamType, TaskQueue, TypedDisTubeEvents, checkIntents, checkInvalidKey, chooseBestVideoFormat, DisTube as default, defaultFilters, defaultOptions, formatDuration, isClientInstance, isGuildInstance, isMemberInstance, isMessageInstance, isObject, isRecord, isSnowflake, isSupportedVoiceChannel, isTextChannelInstance, isURL, isVoiceChannelEmpty, objectKeys, parseNumber, resolveGuildId, toSecond, version };
